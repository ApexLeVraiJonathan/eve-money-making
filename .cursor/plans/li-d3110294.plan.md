<!-- d3110294-1ec7-4890-a33d-fd1d43a0a66e a4db5304-fb89-4389-b19e-6bab8c817020 -->
# Liquidity & Arbitrage Knobs Implementation Plan

## 1. Backend: Liquidity DTOs and Service

1.1 **Relax window limits and align DTOs**

- In `apps/api/src/market/dto/liquidity-check-request.dto.ts`, remove `@Max(30)` on `windowDays` (no upper bound) and keep minimum validation (`@Min(1)`).
- In `apps/api/src/market/dto/item-stats-request.dto.ts`, remove `@Max(30)` on `windowDays` as well, to allow longer history for item stats.

1.2 **Extend `LiquidityService.runCheck` options for arbitrage control**

- In `apps/api/src/market/services/liquidity.service.ts`, keep the public controller path unchanged, but formalize the `params` object type to include all current knobs plus potential future ones (e.g. destination filters if needed later).
- Ensure call sites (LiquidityController and ArbitrageService) still compile after the type tightening.

## 2. Backend: Arbitrage DTO & Config – Liquidity knobs and renames

2.1 **Rename `arbitrageMultiplier` → `maxInventoryDays`**

- In `apps/api/src/market/dto/check-request.dto.ts`, rename the field to `maxInventoryDays` with updated description ("maximum days of average volume to hold as inventory").
- In `apps/api/src/market/services/arbitrage.service.ts`, replace all uses of `arbitrageMultiplier` with `maxInventoryDays` and adjust variable names/comments accordingly:
- `plannedArbitrageQuantity = recentDailyVolume * maxInventoryDays`.
- In `apps/api/src/common/config.ts` (or wherever `AppConfig.arbitrage()` is defined), rename the corresponding config property and update defaults.
- Update any other backend references (e.g. tests) that still refer to `arbitrageMultiplier`.

2.2 **Add liquidity-control knobs to `ArbitrageCheckRequest`**

- In `check-request.dto.ts`, add optional, clearly prefixed liquidity fields, e.g.:
- `liquidityWindowDays?: number` (already present, keep as-is but update docstring to clarify it drives liquidity).
- `liquidityMinCoverageRatio?: number`.
- `liquidityMinLiquidityThresholdISK?: number`.
- `liquidityMinWindowTrades?: number`.
- In `ArbitrageService.check`, when calling `liquidity.runCheck`, map these into the expected structure:
- `windowDays: params?.liquidityWindowDays`.
- `minCoverageRatio`, `minLiquidityThresholdISK`, `minWindowTrades` using the new fields if provided; otherwise fall back to LiquidityService’s defaults.
- Keep `/liquidity/check` behavior unchanged; arbitrage simply gains its own ability to tighten/loosen the liquidity universe.

2.3 **Add destination selection knobs to `ArbitrageCheckRequest`**

- In `check-request.dto.ts`, add optional arrays:
- `destinationStationIds?: number[]`.
- `excludeDestinationStationIds?: number[]`.
- In `ArbitrageService.check`, after retrieving `liquidity`, filter the `stations` array:
- If `destinationStationIds` is set, keep only those station IDs.
- Then apply `excludeDestinationStationIds` as a blacklist.
- Ensure default behavior (no fields set) continues to use all tracked stations.

## 3. Backend: Margin, price deviation, and inventory behavior

3.1 **Add minimum margin % knob**

- In `check-request.dto.ts`, add `minMarginPercent?: number` with validation (e.g. 0–1000) and docs stating it is the minimum after-fee margin.
- In `AppConfig.arbitrage()`, add a default `minMarginPercent` of 10.
- In `ArbitrageService.check`, after computing `margin`, drop opportunities where `margin < minMarginPercent`.
- Ensure `minTotalProfitISK` is still honored alongside this new filter.

3.2 **Add `maxPriceDeviationMultiple` knob**

- In `check-request.dto.ts`, add `maxPriceDeviationMultiple?: number` with a typical range (e.g. `@Min(1)`; no strict max) and docs noting that if omitted, price deviation is ignored.
- In `ArbitrageService.check`, after resolving `destinationPrice` and `liquidityavg`:
- If `maxPriceDeviationMultiple` is provided and `liquidityavg > 0`, drop the opportunity if `destinationPrice > liquidityavg * maxPriceDeviationMultiple`.
- Keep behavior symmetric only on the high side initially (as discussed) so that extremely high spikes are filtered but “too cheap” cases remain.
- Ensure this filter runs before computing totals, so extreme outliers do not influence aggregated station stats.

3.3 **Refine inventory constraints using `maxInventoryDays`**

- In `ArbitrageService.check`, extend the inventory logic:
- Compute current remaining stock per `(typeId, destinationStationId)` as today.
- For each candidate, compute `allowedMaxUnits = item.avgDailyAmount * maxInventoryDays`.
- Compute `projectedUnits = remainingExisting + arbitrageQuantity`.
- Add two new knobs to `ArbitrageCheckRequest`:
- `disableInventoryLimit?: boolean` – when true, ignore inventory checks entirely (for market analysis).
- `allowInventoryTopOff?: boolean` – when true and inventory limit is enabled, adjust `arbitrageQuantity` down to `max(0, allowedMaxUnits - remainingExisting)` instead of skipping the item; if the adjusted quantity becomes 0, skip.
- Replace the current simple "skip if any remaining stock" logic with this three-way behavior:
- If `disableInventoryLimit` → no inventory-based skipping or top-off.
- Else if `allowInventoryTopOff` → use the adjusted quantity based on `maxInventoryDays`.
- Else (default) → preserve existing conservative behavior (skip items with remaining stock).

## 4. Backend: Plan-packages orchestration

4.1 **Extend `PlanPackagesRequest` with nested options**

- In `apps/api/src/market/dto/plan-packages-request.dto.ts`, add two optional nested config objects:
- `liquidityOptions?: { windowDays?: number; minCoverageRatio?: number; minLiquidityThresholdISK?: number; minWindowTrades?: number; }` (shape compatible with Liquidity/Arbitrage liquidity knobs).
- `arbitrageOptions?: { maxInventoryDays?: number; minMarginPercent?: number; maxPriceDeviationMultiple?: number; destinationStationIds?: number[]; excludeDestinationStationIds?: number[]; disableInventoryLimit?: boolean; allowInventoryTopOff?: boolean; salesTaxPercent?: number; brokerFeePercent?: number; minTotalProfitISK?: number; }`.
- Use class-validator decorators and Swagger metadata for each field, following existing style.

4.2 **Wire nested options through `ArbitrageService.planPackages`**

- In `ArbitrageService.planPackages`:
- When calling `this.check`, pass through the relevant options extracted from `params.liquidityOptions` and `params.arbitrageOptions` (e.g. `liquidityWindowDays`, `liquidityMinCoverageRatio`, etc.).
- Keep default behavior identical to today when `liquidityOptions` / `arbitrageOptions` are omitted.
- Ensure the packaging step itself remains unchanged (it consumes `PlanResult`), but has richer upstream control.

4.3 **Update any backend tests for planner behavior**

- Locate existing tests around planning and cycles (e.g. in `apps/api/test`), and update or add tests to cover:
- `plan-packages` using defaults (backward compatibility).
- `plan-packages` with non-default `liquidityOptions` and `arbitrageOptions`.

## 5. Frontend: Tradecraft admin – Liquidity page

5.1 **Create market liquidity hooks**

- In `apps/web/app/tradecraft/api/market/liquidity.hooks.ts`, add typed hooks for:
- `useLiquidityCheck` calling POST `/liquidity/check` (admin-authenticated) with `LiquidityCheckRequest` shape.
- `useLiquidityItemStats` calling POST `/liquidity/item-stats` with `LiquidityItemStatsRequest` shape.
- Reuse existing API client patterns from `tradecraft/api/market/arbitrage.hooks.ts` and other market hooks.

5.2 **Add `/tradecraft/admin/liquidity` page**

- In `apps/web/app/tradecraft/admin/liquidity/page.tsx`, implement a new admin page:
- Two modes: e.g. “Station Liquidity Scan” (for `runCheck`) and “Item Liquidity Stats” (for `getItemStats`).
- Forms exposing all relevant knobs:
- For runCheck: station selector/ID, `windowDays`, `minCoverageRatio`, `minLiquidityThresholdISK`, `minWindowTrades`.
- For itemStats: item selector (ID or name), station selector (ID or name), `isBuyOrder`, `windowDays`.
- Results table/cards showing key metrics (coverage, avg daily volume, ISK/day, trades/day, and price averages), with simple formatting consistent with existing admin pages.

## 6. Frontend: Tradecraft admin – Arbitrage page

6.1 **Extend arbitrage hooks with new DTO fields**

- Update `apps/web/app/tradecraft/api/market/arbitrage.hooks.ts` types and functions to match the new `ArbitrageCheckRequest` fields and response shape (including `minMarginPercent`, `maxPriceDeviationMultiple`, destination filters, inventory flags, and `maxInventoryDays`).

6.2 **Add `/tradecraft/admin/arbitrage` page**

- In `apps/web/app/tradecraft/admin/arbitrage/page.tsx`, create a UI for running `/arbitrage/check` directly:
- Provide inputs for: `sourceStationId`, `maxInventoryDays`, `minMarginPercent`, `minTotalProfitISK`, `maxPriceDeviationMultiple`, destination include/exclude lists, liquidity window/thresholds, and fee percentages.
- Include a toggle (checkbox) for `disableInventoryLimit` to support pure market analysis not impacted by current cycle inventory.
- Optionally include a toggle for `allowInventoryTopOff`.
- Render results grouped by destination station with summary metrics and a sortable table of opportunities.

## 7. Frontend: Tradecraft admin – Planner page enhancements

7.1 **Update planner API usage to support new options**

- In `apps/web/app/tradecraft/admin/planner/page.tsx`, adjust the request shape sent to `/arbitrage/plan-packages` to include the new `liquidityOptions` and `arbitrageOptions` when the user selects advanced mode.
- Keep the current simple flow working (no options) so existing UX and defaults remain intact.

7.2 **Introduce basic vs advanced planner modes**

- On the planner page, add a UI control (e.g. “Advanced settings” toggle or tab):
- **Basic mode**: Expose only the core packaging parameters (investment ISK, package capacity, shipping costs, etc.), and rely on backend defaults for liquidity and arbitrage.
- **Advanced mode**: Show sections for:
- Liquidity options (window, coverage, liquidity threshold, trades/day).
- Arbitrage options (maxInventoryDays, minMarginPercent, destination filters, price deviation multiple, inventory toggles, fees, minTotalProfitISK).
- Ensure the advanced form builds `PlanPackagesRequest` with nested `liquidityOptions` and `arbitrageOptions` matching the backend DTO.

7.3 **Align planner UI with Liquidity/Arbitrage pages**

- Reuse form components or at least consistent labels/placeholders so admins see the same terminology across `Liquidity`, `Arbitrage`, and `Planner` pages.
- Consider a small inline help text for key knobs (maxInventoryDays, minMarginPercent, maxPriceDeviationMultiple) to explain their risk/behavior.

## 8. Testing, validation, and docs

8.1 **Backend tests and validation**

- Update or add tests around `liquidity.runCheck`, `ArbitrageService.check`, and `planPackages` to cover:
- New defaults (10% min margin, no window max) and edge cases (very large windows, no deviation limit, disabled inventory limit, top-off behavior).
- Destination include/exclude filtering and their interaction with tracked stations.

8.2 **Frontend tests / manual QA**

- If there are existing frontend tests (e.g. Vitest/RTL), extend them to cover the new Liquidity and Arbitrage admin pages’ basic behaviors and planner’s advanced mode.
- At minimum, plan a manual QA checklist for:
- Running liquidity scans with different windows and thresholds.
- Running arbitrage checks with and without inventory limits and price deviation constraints.
- Running planner in basic vs advanced mode and confirming that all steps (Liquidity → Arbitrage → Packaging) behave as expected.

8.3 **Docs and inline comments**

- Update any relevant docs in `docs/` (e.g. `AUTH_ARCHITECTURE`-style or planner docs) to describe the new knobs and how they interact.
- Add concise inline comments around the trickier financial logic (inventory days, deviation filters) to capture the real-world reasoning for future maintainers.

### To-dos

- [x] Relax liquidity window limits, keep validations, and formalize LiquidityService.runCheck params for extended use by arbitrage.
- [x] Rename arbitrageMultiplier to maxInventoryDays, add liquidity control knobs, margin and deviation filters, destination selection, and inventory options to ArbitrageCheckRequest and AppConfig.
- [x] Update ArbitrageService.check and planPackages to use new knobs, nested PlanPackagesRequest options, and refined inventory behavior.
- [x] Add nested liquidity and arbitrage options to PlanPackagesRequest and wire them through ArbitrageService.planPackages (backend tests deferred).
- [x] Add tradecraft liquidity hooks and admin Liquidity page exposing runCheck and item-stats modes with all knobs (including itemId and stationName, with tooltips and single-column layout).
- [ ] Extend arbitrage hooks and add admin Arbitrage page with all check knobs including inventory and price deviation controls.
- [ ] Enhance tradecraft admin planner page to support basic vs advanced modes and send nested liquidity/arbitrage options to plan-packages.
- [ ] Update backend tests, add any frontend tests, and refresh docs to cover new liquidity and arbitrage parameters and flows.