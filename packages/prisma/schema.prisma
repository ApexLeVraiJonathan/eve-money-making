generator client {
  provider = "prisma-client-js"
  output   = "./client"
}

datasource db {
  provider = "postgresql"
}

/// Character platform role (authorization)
enum CharacterRole {
  USER
  LOGISTICS
}

/// Character management type (user-owned vs system-owned)
enum CharacterManagedBy {
  USER
  SYSTEM
}

/// Character function for trading workflows
enum CharacterFunction {
  SELLER
  BUYER
}

/// Home market/location for convenience filtering
enum CharacterLocation {
  JITA
  DODIXIE
  AMARR
  HEK
  RENS
  CN
}

/// Participation status for user opt-ins to cycles
enum ParticipationStatus {
  AWAITING_INVESTMENT
  AWAITING_VALIDATION
  OPTED_IN
  OPTED_OUT
  AWAITING_PAYOUT
  COMPLETED
  REFUNDED
}

/// Scope for parameter profiles (which tool/page they belong to)
enum ParameterProfileScope {
  LIQUIDITY
  ARBITRAGE
  PLANNER
}

/// Strategy Lab run lifecycle status
enum TradeStrategyRunStatus {
  QUEUED
  RUNNING
  COMPLETED
  FAILED
  CANCELLED
}

/// How simulated sell-through is modeled
enum TradeStrategySellModel {
  VOLUME_SHARE
  CALIBRATED_CAPTURE
}

/// How we pick the daily price proxy from MarketOrderTradeDaily
enum TradeStrategyPriceModel {
  LOW
  AVG
  HIGH
}

/// Rollover type for automatic reinvestment
enum RolloverType {
  FULL_PAYOUT // Roll over entire payout (initial + profit), capped at 20B
  INITIAL_ONLY // Roll over only initial investment amount
  CUSTOM_AMOUNT // Roll over user-specified amount (≤ initial)
}

/// Per-user automatic rollover preference for newly planned cycles.
/// Note: while `RolloverType` includes CUSTOM_AMOUNT, auto-rollover settings
/// intentionally only allow FULL_PAYOUT or INITIAL_ONLY (enforced in API).
model AutoRolloverSettings {
  /// 1:1 with User (we use userId as the primary key)
  userId String @id @map("user_id")
  user   User   @relation(fields: [userId], references: [id], onDelete: Cascade)

  enabled            Boolean      @default(false) @map("enabled")
  defaultRolloverType RolloverType @default(INITIAL_ONLY) @map("default_rollover_type")

  createdAt DateTime @default(now()) @map("created_at")
  updatedAt DateTime @updatedAt @map("updated_at")

  @@map("auto_rollover_settings")
}

/// Cycle lifecycle status
enum CycleStatus {
  PLANNED
  OPEN
  COMPLETED
}

/// Notification delivery channels (extensible)
enum NotificationChannel {
  DISCORD_DM
}

/// High-level notification types for user-facing events
enum NotificationType {
  CYCLE_PLANNED
  CYCLE_STARTED
  CYCLE_RESULTS
  CYCLE_PAYOUT_SENT
  SKILL_PLAN_REMAP_REMINDER
  SKILL_PLAN_COMPLETION
  /// Reminder when an account's primary PLEX/subscription time is ending
  PLEX_ENDING
  /// Reminder when an account's MCT slot is ending
  MCT_ENDING
  /// Reminder when a character's active booster is ending
  BOOSTER_ENDING
  /// Reminder when a character has training time available but no active queue
  TRAINING_QUEUE_IDLE
  /// Skill farm: character has enough SP for at least one new extractor
  SKILL_FARM_EXTRACTOR_READY
  /// Skill farm: character's training queue is low/empty (3d, 1d, or expired)
  SKILL_FARM_QUEUE_LOW
}

model TypeId {
  id        Int      @id @map("type_id")
  published Boolean
  name      String   @map("type_name")
  volume    Decimal? @map("volume_m3") @db.Decimal(28, 2)
  createdAt DateTime @default(now()) @map("created_at")
  updatedAt DateTime @updatedAt @map("updated_at")

  marketTrades    MarketOrderTradeDaily[]
  strategyRunPositions TradeStrategyRunPosition[]
  SkillDefinition SkillDefinition[]

  @@map("item_types")
}

model RegionId {
  id        Int             @id @map("region_id")
  name      String          @map("region_name")
  systems   SolarSystemId[]
  createdAt DateTime        @default(now()) @map("created_at")
  updatedAt DateTime        @updatedAt @map("updated_at")

  marketTrades MarketOrderTradeDaily[]

  @@map("regions")
}

model SolarSystemId {
  id        Int         @id @map("solar_system_id")
  regionId  Int         @map("region_id")
  region    RegionId    @relation(fields: [regionId], references: [id], onDelete: Restrict, onUpdate: Cascade)
  stations  StationId[]
  name      String      @map("solar_system_name")
  createdAt DateTime    @default(now()) @map("created_at")
  updatedAt DateTime    @updatedAt @map("updated_at")

  @@index([regionId])
  @@map("solar_systems")
}

model StationId {
  id             Int              @id @map("station_id")
  solarSystemId  Int              @map("solar_system_id")
  solarSystem    SolarSystemId    @relation(fields: [solarSystemId], references: [id], onDelete: Restrict, onUpdate: Cascade)
  name           String           @map("station_name")
  createdAt      DateTime         @default(now()) @map("created_at")
  updatedAt      DateTime         @updatedAt @map("updated_at")
  TrackedStation TrackedStation[]

  marketTrades MarketOrderTradeDaily[]

  @@index([solarSystemId])
  @@map("stations")
}

model TrackedStation {
  id        String    @id @default(uuid()) @map("id")
  stationId Int       @map("station_id")
  station   StationId @relation(fields: [stationId], references: [id], onDelete: Restrict, onUpdate: Cascade)
  createdAt DateTime  @default(now()) @map("created_at")
  updatedAt DateTime  @updatedAt @map("updated_at")

  @@index([stationId])
  @@map("tracked_stations")
}

/// Daily aggregated market order trades per station and type
model MarketOrderTradeDaily {
  // Composite primary key for a unique daily aggregate per station/type/side
  scanDate   DateTime @map("scan_date") @db.Date
  locationId Int      @map("location_id")
  typeId     Int      @map("type_id")
  isBuyOrder Boolean  @map("is_buy_order")

  regionId Int     @map("region_id")
  hasGone  Boolean @map("has_gone")
  amount   Int     @map("amount")
  high     Decimal @map("high") @db.Decimal(28, 2)
  low      Decimal @map("low") @db.Decimal(28, 2)
  avg      Decimal @map("avg") @db.Decimal(28, 2)
  orderNum Int     @map("order_num")
  iskValue Decimal @map("isk_value") @db.Decimal(28, 2)

  // Relations
  region  RegionId  @relation(fields: [regionId], references: [id], onDelete: Restrict, onUpdate: Cascade)
  type    TypeId    @relation(fields: [typeId], references: [id], onDelete: Restrict, onUpdate: Cascade)
  station StationId @relation(fields: [locationId], references: [id], onDelete: Restrict, onUpdate: Cascade)

  createdAt DateTime @default(now()) @map("created_at")
  updatedAt DateTime @updatedAt @map("updated_at")

  @@id([scanDate, locationId, typeId, isBuyOrder])
  @@index([regionId])
  @@index([locationId])
  @@index([typeId])
  @@map("market_order_trades_daily")
}

/// Cache for ESI responses (ETag/Expires-aware)
model EsiCacheEntry {
  key          String    @id @map("key")
  etag         String?   @map("etag")
  lastModified String?   @map("last_modified")
  expiresAt    DateTime? @map("expires_at")
  status       Int?      @map("status")
  body         Json?     @map("body")
  createdAt    DateTime  @default(now()) @map("created_at")
  updatedAt    DateTime  @updatedAt @map("updated_at")

  @@index([expiresAt])
  @@map("esi_cache_entries")
}

/// Users of the application (can be single owner for now)
model User {
  id                 String        @id @default(uuid()) @map("id")
  email              String?       @unique @map("email")
  role               String        @default("USER") @map("role")
  primaryCharacterId Int?          @unique @map("primary_character_id")
  primaryCharacter   EveCharacter? @relation("UserPrimaryCharacter", fields: [primaryCharacterId], references: [id], onDelete: SetNull)
  createdAt          DateTime      @default(now()) @map("created_at")
  updatedAt          DateTime      @updatedAt @map("updated_at")
  /// Enabled application features for this user (e.g., CHARACTERS, TRADECRAFT)
  enabledFeatures    Json?         @map("enabled_features")

  characters          EveCharacter[]       @relation("UserCharacters")
  EveAccount          EveAccount[]
  SkillPlan           SkillPlan[]
  /// JingleYield programs this user participates in
  jingleYieldPrograms JingleYieldProgram[]

  discordAccounts          DiscordAccount[]
  notificationPreferences  NotificationPreference[]
  SkillFarmSettings        SkillFarmSettings[]
  SkillFarmCharacterConfig SkillFarmCharacterConfig[]

  autoRolloverSettings AutoRolloverSettings?

  /// Optional admin override for max allowed participation (0..20B ISK)
  tradecraftMaxParticipationIsk Decimal? @map("tradecraft_max_participation_isk") @db.Decimal(28, 2)

  /// Tradecraft: max user-funded principal that can be invested (defaults to 10B if null)
  tradecraftPrincipalCapIsk Decimal? @map("tradecraft_principal_cap_isk") @db.Decimal(28, 2)
  /// Tradecraft: max total invested (principal + reinvested interest) (defaults to 20B if null)
  tradecraftMaximumCapIsk   Decimal? @map("tradecraft_maximum_cap_isk") @db.Decimal(28, 2)

  @@map("app_users")
}

/// Linked EVE characters
model EveCharacter {
  id               Int                @id @map("character_id")
  name             String             @map("character_name")
  ownerHash        String             @map("owner_hash")
  userId           String?            @map("user_id")
  user             User?              @relation("UserCharacters", fields: [userId], references: [id], onDelete: SetNull)
  userAsPrimaryFor User?              @relation("UserPrimaryCharacter")
  eveAccountId     String?            @map("eve_account_id")
  eveAccount       EveAccount?        @relation(fields: [eveAccountId], references: [id], onDelete: SetNull)
  role             CharacterRole      @default(USER) @map("role")
  function         CharacterFunction? @map("function")
  location         CharacterLocation? @map("location")
  managedBy        CharacterManagedBy @default(USER) @map("managed_by")
  notes            String?            @map("notes")
  createdAt        DateTime           @default(now()) @map("created_at")
  updatedAt        DateTime           @updatedAt @map("updated_at")

  token                    CharacterToken?
  CharacterBoosterPeriod   CharacterBoosterPeriod[]
  SkillPlanAssignment      SkillPlanAssignment[]
  SkillFarmCharacterConfig SkillFarmCharacterConfig[]
  /// Cycle ledger entries where this character is the beneficiary (admin repayments, etc.)
  beneficiaryLedgerEntries CycleLedgerEntry[]
  /// JingleYield programs where this character is the admin funding character
  adminJingleYieldPrograms JingleYieldProgram[]

  @@index([ownerHash])
  @@index([userId])
  @@map("eve_characters")
}

/// Stored tokens per character (one active token set per character)
model CharacterToken {
  id                   String       @id @default(uuid()) @map("id")
  characterId          Int          @unique @map("character_id")
  character            EveCharacter @relation(fields: [characterId], references: [id], onDelete: Cascade)
  tokenType            String       @map("token_type")
  accessToken          String       @map("access_token")
  accessTokenExpiresAt DateTime     @map("access_expires_at")
  refreshTokenEnc      String       @map("refresh_token_enc")
  scopes               String       @map("scopes")
  lastRefreshAt        DateTime?    @map("last_refresh_at")
  refreshFailAt        DateTime?    @map("refresh_fail_at")
  refreshFailMsg       String?      @map("refresh_fail_msg")
  createdAt            DateTime     @default(now()) @map("created_at")
  updatedAt            DateTime     @updatedAt @map("updated_at")

  @@map("character_tokens")
}

/// Logical EVE accounts (user-defined groups of up to 3 characters)
model EveAccount {
  id        String   @id @default(uuid()) @map("id")
  userId    String   @map("user_id")
  user      User     @relation(fields: [userId], references: [id], onDelete: Cascade)
  /// Optional user-defined label for this account (e.g., “Main skill farm account”)
  label     String?  @map("label")
  notes     String?  @map("notes")
  createdAt DateTime @default(now()) @map("created_at")
  updatedAt DateTime @updatedAt @map("updated_at")

  subscriptions EveAccountSubscription[]
  characters    EveCharacter[]

  @@index([userId])
  @@map("eve_accounts")
}

/// Type of subscription tracked for an EVE account (currently PLEX only)
enum EveAccountSubscriptionType {
  PLEX
  MCT
}

/// Manual tracking of PLEX / subscription periods per EVE account
model EveAccountSubscription {
  id               String                     @id @default(uuid()) @map("id")
  eveAccountId     String                     @map("eve_account_id")
  eveAccount       EveAccount                 @relation(fields: [eveAccountId], references: [id], onDelete: Cascade)
  type             EveAccountSubscriptionType @map("type")
  /// Optional explicit start date; when null, UI can treat this as “open-ended until expiresAt”
  startsAt         DateTime?                  @map("starts_at")
  /// Required expiry date for the subscription/PLEX period
  expiresAt        DateTime                   @map("expires_at")
  renewalCycleDays Int?                       @map("renewal_cycle_days")
  expectedCostIsk  Decimal?                   @map("expected_cost_isk") @db.Decimal(28, 2)
  isActive         Boolean                    @default(true) @map("is_active")
  notes            String?                    @map("notes")
  createdAt        DateTime                   @default(now()) @map("created_at")
  updatedAt        DateTime                   @updatedAt @map("updated_at")

  @@index([eveAccountId])
  @@map("eve_account_subscriptions")
}

/// Manual tracking of training boosters per character
model CharacterBoosterPeriod {
  id          String       @id @default(uuid()) @map("id")
  characterId Int          @map("character_id")
  character   EveCharacter @relation(fields: [characterId], references: [id], onDelete: Cascade)
  boosterName String       @map("booster_name")
  /// Source of this booster entry (e.g., manual, promotion, other system), free-form
  source      String?      @map("source")
  startsAt    DateTime     @map("starts_at")
  expiresAt   DateTime     @map("expires_at")
  notes       String?      @map("notes")
  createdAt   DateTime     @default(now()) @map("created_at")
  updatedAt   DateTime     @updatedAt @map("updated_at")

  @@index([characterId])
  @@map("character_booster_periods")
}

/// Per-user economic assumptions and defaults for skill farm planning
model SkillFarmSettings {
  id                        String   @id @default(uuid()) @map("id")
  userId                    String   @map("user_id")
  user                      User     @relation(fields: [userId], references: [id], onDelete: Cascade)
  /// Effective ISK price per PLEX the user pays (including discounts/Discord trades)
  plexPriceIsk              Decimal? @map("plex_price_isk") @db.Decimal(28, 2)
  /// Effective number of PLEX required for one Omega period
  plexPerOmega              Int?     @map("plex_per_omega")
  /// Effective number of PLEX required for one MCT period
  plexPerMct                Int?     @map("plex_per_mct")
  /// ISK cost per skill extractor
  extractorPriceIsk         Decimal? @map("extractor_price_isk") @db.Decimal(28, 2)
  /// ISK price per skill injector
  injectorPriceIsk          Decimal? @map("injector_price_isk") @db.Decimal(28, 2)
  /// ISK cost per cycle for boosters (e.g., +12 Genius)
  boosterCostPerCycleIsk    Decimal? @map("booster_cost_per_cycle_isk") @db.Decimal(28, 2)
  /// Sales tax percentage (0–100)
  salesTaxPercent           Decimal? @map("sales_tax_percent") @db.Decimal(5, 2)
  /// Broker's fee percentage (0–100)
  brokerFeePercent          Decimal? @map("broker_fee_percent") @db.Decimal(5, 2)
  /// When true, assume injectors are sold via contracts/Discord (skip market fees)
  soldViaContracts          Boolean  @default(false) @map("sold_via_contracts")
  /// Cycle length in days for projections (e.g., 30)
  cycleDays                 Int?     @map("cycle_days")
  /// Estimated management time per cycle in minutes
  managementMinutesPerCycle Int?     @map("management_minutes_per_cycle")
  createdAt                 DateTime @default(now()) @map("created_at")
  updatedAt                 DateTime @updatedAt @map("updated_at")

  @@index([userId])
  @@map("skill_farm_settings")
}

/// Per-character configuration for skill farm tracking
model SkillFarmCharacterConfig {
  id                     String       @id @default(uuid()) @map("id")
  userId                 String       @map("user_id")
  user                   User         @relation(fields: [userId], references: [id], onDelete: Cascade)
  characterId            Int          @map("character_id")
  character              EveCharacter @relation(fields: [characterId], references: [id], onDelete: Cascade)
  /// Whether the user has marked this character as a skill farm candidate
  isCandidate            Boolean      @default(false) @map("is_candidate")
  /// Whether this character is part of the user's active skill farm
  isActiveFarm           Boolean      @default(false) @map("is_active_farm")
  /// Optional linked skill plan used to define farmable skills
  farmPlanId             String?      @map("farm_plan_id")
  farmPlan               SkillPlan?   @relation(fields: [farmPlanId], references: [id], onDelete: SetNull)
  /// Whether this character should be included in skill-farm notifications
  includeInNotifications Boolean      @default(true) @map("include_in_notifications")
  createdAt              DateTime     @default(now()) @map("created_at")
  updatedAt              DateTime     @updatedAt @map("updated_at")

  @@unique([userId, characterId], name: "skill_farm_user_character_unique")
  @@index([characterId])
  @@index([farmPlanId])
  @@map("skill_farm_character_configs")
}

/// User-owned skill plans for training/optimization (game-importable)
model SkillPlan {
  id                        String    @id @default(uuid()) @map("id")
  userId                    String    @map("user_id")
  user                      User      @relation(fields: [userId], references: [id], onDelete: Cascade)
  name                      String    @map("name")
  description               String?   @map("description")
  /// Optional cached total estimated training time in seconds for this plan
  totalEstimatedTimeSeconds Int?      @map("total_estimated_time_seconds")
  /// Optional free-form tags for organizing plans (stored as JSON string array)
  tags                      Json?     @map("tags")
  /// Optional archived timestamp; when set, the plan is hidden from default lists
  archivedAt                DateTime? @map("archived_at")
  /// Optional JSON configuration for plan-wide settings (attributes/implants/remaps, etc.)
  config                    Json?     @map("config")
  createdAt                 DateTime  @default(now()) @map("created_at")
  updatedAt                 DateTime  @updatedAt @map("updated_at")

  steps                    SkillPlanStep[]
  assignments              SkillPlanAssignment[]
  SkillFarmCharacterConfig SkillFarmCharacterConfig[]

  @@index([userId])
  @@map("skill_plans")
}

/// Ordered steps within a skill plan (maps to EVE skill type IDs)
model SkillPlanStep {
  id          String    @id @default(uuid()) @map("id")
  planId      String    @map("plan_id")
  plan        SkillPlan @relation(fields: [planId], references: [id], onDelete: Cascade)
  /// 0-based or 1-based order of this step within the plan (UI can choose convention)
  order       Int       @map("order")
  /// EVE skill type ID (maps to TypeId.id / EVE skill type)
  skillId     Int       @map("skill_id")
  /// Target level I–V (1–5) for this skill
  targetLevel Int       @map("target_level")
  notes       String?   @map("notes")
  createdAt   DateTime  @default(now()) @map("created_at")
  updatedAt   DateTime  @updatedAt @map("updated_at")

  @@index([planId])
  @@map("skill_plan_steps")
}

/// Assignment linking a skill plan to a specific EVE character, with per-assignment settings
model SkillPlanAssignment {
  id          String       @id @default(uuid()) @map("id")
  skillPlanId String       @map("skill_plan_id")
  skillPlan   SkillPlan    @relation(fields: [skillPlanId], references: [id], onDelete: Cascade)
  characterId Int          @map("character_id")
  character   EveCharacter @relation(fields: [characterId], references: [id], onDelete: Cascade)
  /// Optional JSON settings for this assignment (e.g. implant/booster assumptions, notification prefs)
  settings    Json?        @map("settings")
  createdAt   DateTime     @default(now()) @map("created_at")
  updatedAt   DateTime     @updatedAt @map("updated_at")

  @@index([skillPlanId])
  @@index([characterId])
  @@map("skill_plan_assignments")
}

/// Investment cycles for grouping commits and cash flows
model Cycle {
  id        String      @id @default(uuid()) @map("id")
  name      String?     @map("name")
  status    CycleStatus @default(PLANNED) @map("status")
  startedAt DateTime    @map("started_at")
  closedAt  DateTime?   @map("closed_at")
  createdAt DateTime    @default(now()) @map("created_at")
  updatedAt DateTime    @updatedAt @map("updated_at")

  /// Optional: amount of new ISK injected at cycle start (user-provided)
  initialInjectionIsk Decimal? @map("initial_injection_isk") @db.Decimal(28, 2)
  /// Optional: total starting capital at cycle start (injection + carryover cash/inventory)
  initialCapitalIsk   Decimal? @map("initial_capital_isk") @db.Decimal(28, 2)

  ledgerEntries                CycleLedgerEntry[]
  CycleCapitalCache            CycleCapitalCache[]
  participations               CycleParticipation[]
  cycleLines                   CycleLine[]
  cycleFeeEvents               CycleFeeEvent[]
  cycleSnapshots               CycleSnapshot[]
  committedPackages            CommittedPackage[]
  /// JingleYield programs that start in this cycle
  startJingleYieldPrograms     JingleYieldProgram[] @relation("JingleYieldStartCycle")
  /// JingleYield programs that complete in this cycle
  completedJingleYieldPrograms JingleYieldProgram[] @relation("JingleYieldCompletedCycle")

  @@map("cycles")
}

/// Cached capital/NAV snapshot per cycle
model CycleCapitalCache {
  cycleId   String   @id @map("cycle_id")
  asOf      DateTime @map("as_of")
  snapshot  Json     @map("snapshot")
  createdAt DateTime @default(now()) @map("created_at")
  updatedAt DateTime @updatedAt @map("updated_at")

  cycle Cycle @relation(fields: [cycleId], references: [id], onDelete: Cascade)

  @@map("cycle_capital_cache")
}

/// Ledger entries for investor cash flows ONLY (deposits, withdrawals, payouts)
/// NOTE: No longer used for executions (buys/sells). Use BuyAllocation/SellAllocation instead.
model CycleLedgerEntry {
  id         String   @id @default(uuid()) @map("id")
  cycleId    String   @map("cycle_id")
  cycle      Cycle    @relation(fields: [cycleId], references: [id], onDelete: Cascade, onUpdate: Cascade)
  occurredAt DateTime @default(now()) @map("occurred_at")
  entryType  String   @map("entry_type") // deposit | withdrawal | payout
  amount     Decimal  @map("amount_isk") @db.Decimal(28, 2)
  memo       String?  @map("memo")

  /// Optional beneficiary type for payouts (user | admin)
  beneficiaryType        String?       @map("beneficiary_type")
  /// Optional EVE character receiving this payout (used for admin JingleYield repayments)
  beneficiaryCharacterId Int?          @map("beneficiary_character_id")
  beneficiaryCharacter   EveCharacter? @relation(fields: [beneficiaryCharacterId], references: [id], onDelete: SetNull)

  /// Optional link to a JingleYield program when this entry represents an admin repayment
  jingleYieldProgramId String?             @map("jingle_yield_program_id")
  jingleYieldProgram   JingleYieldProgram? @relation(fields: [jingleYieldProgramId], references: [id], onDelete: SetNull)

  /// Link to user participation when this entry represents a deposit/refund/payout
  participationId String?             @map("participation_id")
  participation   CycleParticipation? @relation(fields: [participationId], references: [id], onDelete: SetNull)

  createdAt DateTime @default(now()) @map("created_at")
  updatedAt DateTime @updatedAt @map("updated_at")

  @@index([cycleId])
  @@index([participationId])
  @@index([entryType])
  @@index([beneficiaryCharacterId])
  @@index([jingleYieldProgramId])
  @@map("cycle_ledger")
}

/// Raw ESI wallet transactions (idempotent store)
model WalletTransaction {
  characterId   Int      @map("character_id")
  transactionId BigInt   @map("transaction_id")
  date          DateTime @map("date")
  isBuy         Boolean  @map("is_buy")
  locationId    Int      @map("location_id")
  typeId        Int      @map("type_id")
  clientId      Int?     @map("client_id")
  quantity      Int      @map("quantity")
  unitPrice     Decimal  @map("unit_price") @db.Decimal(28, 2)
  journalRefId  BigInt?  @map("journal_ref_id")
  createdAt     DateTime @default(now()) @map("created_at")

  @@id([characterId, transactionId])
  @@index([characterId])
  @@index([date])
  @@map("wallet_transactions")
}

/// Raw ESI wallet journal entries (idempotent store)
model WalletJournalEntry {
  characterId   Int      @map("character_id")
  journalId     BigInt   @map("journal_id")
  date          DateTime @map("date")
  refType       String   @map("ref_type")
  amount        Decimal  @map("amount") @db.Decimal(28, 2)
  balance       Decimal? @map("balance") @db.Decimal(28, 2)
  contextId     BigInt?  @map("context_id")
  contextIdType String?  @map("context_id_type")
  description   String?  @map("description")
  reason        String?  @map("reason")
  firstPartyId  Int?     @map("first_party_id")
  secondPartyId Int?     @map("second_party_id")
  tax           Decimal? @map("tax") @db.Decimal(28, 2)
  taxReceiverId Int?     @map("tax_receiver_id")
  createdAt     DateTime @default(now()) @map("created_at")

  @@id([characterId, journalId])
  @@index([characterId])
  @@index([date])
  @@map("wallet_journal")
}

/// User participation (opt-in) for upcoming investment cycles
model CycleParticipation {
  id                  String              @id @default(uuid()) @map("id")
  cycleId             String              @map("cycle_id")
  cycle               Cycle               @relation(fields: [cycleId], references: [id], onDelete: Cascade)
  userId              String?             @map("user_id")
  characterName       String              @map("character_name")
  amountIsk           Decimal             @map("amount_isk") @db.Decimal(28, 2)
  /// User-funded principal portion of this participation (does not include reinvested interest)
  userPrincipalIsk    Decimal?            @map("user_principal_isk") @db.Decimal(28, 2)
  memo                String              @map("memo") // Removed @unique - same memo for all users in a cycle
  status              ParticipationStatus @map("status")
  walletJournalId     BigInt?             @map("wallet_journal_id")
  validatedAt         DateTime?           @map("validated_at")
  optedOutAt          DateTime?           @map("opted_out_at")
  refundAmountIsk     Decimal?            @map("refund_amount_isk") @db.Decimal(28, 2)
  refundedAt          DateTime?           @map("refunded_at")
  payoutAmountIsk     Decimal?            @map("payout_amount_isk") @db.Decimal(28, 2)
  payoutPaidAt        DateTime?           @map("payout_paid_at")
  rolloverDeductedIsk Decimal?            @map("rollover_deducted_isk") @db.Decimal(28, 2) // Amount deducted from payout for rollover
  createdAt           DateTime            @default(now()) @map("created_at")
  updatedAt           DateTime            @updatedAt @map("updated_at")

  // Rollover fields for automatic reinvestment
  rolloverType                RolloverType?        @map("rollover_type")
  rolloverRequestedAmountIsk  Decimal?             @map("rollover_requested_amount_isk") @db.Decimal(28, 2)
  rolloverFromParticipationId String?              @map("rollover_from_participation_id")
  rolloverFromParticipation   CycleParticipation?  @relation("RolloverChain", fields: [rolloverFromParticipationId], references: [id], onDelete: SetNull)
  rolloverToParticipations    CycleParticipation[] @relation("RolloverChain")

  ledgerEntries CycleLedgerEntry[]

  /// Optional link to an active JingleYield program this participation belongs to
  jingleYieldProgramId String?             @map("jingle_yield_program_id")
  jingleYieldProgram   JingleYieldProgram? @relation(fields: [jingleYieldProgramId], references: [id], onDelete: SetNull)

  /// When set, this participation is the root for a specific JingleYield program
  rootForJingleYieldProgram JingleYieldProgram? @relation("JingleYieldRootParticipation")

  @@unique([cycleId, userId], name: "cycle_user_unique")
  @@index([cycleId])
  @@index([rolloverFromParticipationId])
  @@index([jingleYieldProgramId])
  @@map("cycle_participations")
}

/// JingleYield seeded-investment program per user
model JingleYieldProgram {
  id String @id @default(uuid()) @map("id")

  /// User participating in this JingleYield program
  userId String @map("user_id")
  user   User   @relation(fields: [userId], references: [id], onDelete: Cascade)

  /// Admin EVE character that funded the 2B principal
  adminCharacterId Int          @map("admin_character_id")
  adminCharacter   EveCharacter @relation(fields: [adminCharacterId], references: [id], onDelete: Restrict)

  /// Root participation where the 2B principal was first committed
  rootParticipationId String             @unique @map("root_participation_id")
  rootParticipation   CycleParticipation @relation("JingleYieldRootParticipation", fields: [rootParticipationId], references: [id], onDelete: Restrict)

  /// Program status: ACTIVE | COMPLETED_CONTINUING | COMPLETED_CLOSED_LOSS
  status String @default("ACTIVE") @map("status")

  /// Locked principal provided by admin (typically 2B)
  lockedPrincipalIsk Decimal @map("locked_principal_isk") @db.Decimal(28, 2)

  /// Cumulative interest earned while this JY program is active
  cumulativeInterestIsk Decimal @default(0) @map("cumulative_interest_isk") @db.Decimal(28, 2)

  /// Target interest threshold to auto-complete the program (default 2B)
  targetInterestIsk Decimal @default(2000000000) @map("target_interest_isk") @db.Decimal(28, 2)

  /// Cycle where the program started
  startCycleId String @map("start_cycle_id")
  startCycle   Cycle  @relation("JingleYieldStartCycle", fields: [startCycleId], references: [id], onDelete: Restrict)

  /// Minimum number of cycles before capital can be repaid (default 12)
  minCycles Int @default(12) @map("min_cycles")

  /// Optional cycle when the program completed
  completedCycleId String? @map("completed_cycle_id")
  completedCycle   Cycle?  @relation("JingleYieldCompletedCycle", fields: [completedCycleId], references: [id], onDelete: SetNull)

  /// Participations that belong to this JingleYield program (across cycles)
  participations CycleParticipation[]

  /// Ledger entries representing admin repayments for this program
  ledgerEntries CycleLedgerEntry[]

  createdAt DateTime @default(now()) @map("created_at")
  updatedAt DateTime @updatedAt @map("updated_at")

  @@index([userId])
  @@index([adminCharacterId])
  @@index([startCycleId])
  @@index([completedCycleId])
  @@map("jingle_yield_programs")
}

/// Temporary storage for OAuth state during character linking flow
model OAuthState {
  id           String   @id @default(uuid())
  state        String   @unique
  codeVerifier String   @map("code_verifier")
  userId       String?  @map("user_id")
  returnUrl    String?  @map("return_url")
  createdAt    DateTime @default(now()) @map("created_at")
  expiresAt    DateTime @map("expires_at")

  @@index([state])
  @@index([expiresAt])
  @@map("oauth_states")
}

/// Linked Discord account for a user (via OAuth)
model DiscordAccount {
  id            String   @id @default(uuid()) @map("id")
  userId        String   @map("user_id")
  user          User     @relation(fields: [userId], references: [id], onDelete: Cascade)
  discordUserId String   @map("discord_user_id")
  username      String   @map("username")
  discriminator String?  @map("discriminator")
  avatarUrl     String?  @map("avatar_url")
  linkedAt      DateTime @default(now()) @map("linked_at")
  createdAt     DateTime @default(now()) @map("created_at")
  updatedAt     DateTime @updatedAt @map("updated_at")

  @@unique([discordUserId], name: "discord_user_unique")
  @@index([userId])
  @@map("discord_accounts")
}

/// Per-user notification preferences per channel / type
model NotificationPreference {
  id               String              @id @default(uuid()) @map("id")
  userId           String              @map("user_id")
  user             User                @relation(fields: [userId], references: [id], onDelete: Cascade)
  channel          NotificationChannel @map("channel")
  notificationType NotificationType    @map("notification_type")
  enabled          Boolean             @default(false) @map("enabled")
  createdAt        DateTime            @default(now()) @map("created_at")
  updatedAt        DateTime            @updatedAt @map("updated_at")

  @@unique([userId, channel, notificationType], name: "user_channel_type_unique")
  @@index([userId])
  @@map("notification_preferences")
}

/// Buy commitment line per item per destination for a cycle
model CycleLine {
  id                   String   @id @default(uuid()) @map("id")
  cycleId              String   @map("cycle_id")
  cycle                Cycle    @relation(fields: [cycleId], references: [id], onDelete: Cascade)
  typeId               Int      @map("type_id")
  destinationStationId Int      @map("destination_station_id")
  plannedUnits         Int      @map("planned_units")
  unitsBought          Int      @default(0) @map("units_bought")
  buyCostIsk           Decimal  @default(0) @map("buy_cost_isk") @db.Decimal(28, 2)
  unitsSold            Int      @default(0) @map("units_sold")
  salesGrossIsk        Decimal  @default(0) @map("sales_gross_isk") @db.Decimal(28, 2)
  salesTaxIsk          Decimal  @default(0) @map("sales_tax_isk") @db.Decimal(28, 2)
  salesNetIsk          Decimal  @default(0) @map("sales_net_isk") @db.Decimal(28, 2)
  brokerFeesIsk        Decimal  @default(0) @map("broker_fees_isk") @db.Decimal(28, 2)
  relistFeesIsk        Decimal  @default(0) @map("relist_fees_isk") @db.Decimal(28, 2)
  currentSellPriceIsk  Decimal? @map("current_sell_price_isk") @db.Decimal(28, 2)
  listedUnits          Int      @default(0) @map("listed_units")
  createdAt            DateTime @default(now()) @map("created_at")
  updatedAt            DateTime @updatedAt @map("updated_at")

  /// Rollover tracking from previous cycle
  isRollover          Boolean @default(false) @map("is_rollover")
  rolloverFromCycleId String? @map("rollover_from_cycle_id")
  rolloverFromLineId  String? @map("rollover_from_line_id")

  buyAllocations  BuyAllocation[]
  sellAllocations SellAllocation[]
  packageLinks    PackageCycleLine[]

  @@index([cycleId])
  @@index([typeId])
  @@index([destinationStationId])
  @@index([cycleId, typeId])
  @@index([rolloverFromCycleId])
  @@map("cycle_lines")
}

/// Links a wallet buy transaction to a cycle line with quantity allocated
model BuyAllocation {
  id                  String    @id @default(uuid()) @map("id")
  walletCharacterId   Int?      @map("wallet_character_id")
  walletTransactionId BigInt?   @map("wallet_transaction_id")
  lineId              String    @map("line_id")
  line                CycleLine @relation(fields: [lineId], references: [id], onDelete: Cascade)
  quantity            Int       @map("quantity")
  unitPrice           Decimal   @map("unit_price") @db.Decimal(28, 2)
  createdAt           DateTime  @default(now()) @map("created_at")

  /// Marks synthetic allocations for cycle rollovers (no real wallet transaction)
  isRollover Boolean @default(false) @map("is_rollover")

  @@unique([walletCharacterId, walletTransactionId, lineId])
  @@index([lineId])
  @@index([walletCharacterId, walletTransactionId])
  @@map("buy_allocations")
}

/// Links a wallet sell transaction to a cycle line with quantity allocated
model SellAllocation {
  id                  String    @id @default(uuid()) @map("id")
  walletCharacterId   Int?      @map("wallet_character_id")
  walletTransactionId BigInt?   @map("wallet_transaction_id")
  lineId              String    @map("line_id")
  line                CycleLine @relation(fields: [lineId], references: [id], onDelete: Cascade)
  quantity            Int       @map("quantity")
  unitPrice           Decimal   @map("unit_price") @db.Decimal(28, 2)
  revenueIsk          Decimal   @map("revenue_isk") @db.Decimal(28, 2)
  taxIsk              Decimal   @map("tax_isk") @db.Decimal(28, 2)
  createdAt           DateTime  @default(now()) @map("created_at")

  /// Marks synthetic allocations for cycle rollovers (no real wallet transaction)
  isRollover Boolean @default(false) @map("is_rollover")

  @@unique([walletCharacterId, walletTransactionId, lineId])
  @@index([lineId])
  @@index([walletCharacterId, walletTransactionId])
  @@map("sell_allocations")
}

/// Cycle-level fees (transport, etc.) not tied to specific items
model CycleFeeEvent {
  id         String   @id @default(uuid()) @map("id")
  cycleId    String   @map("cycle_id")
  cycle      Cycle    @relation(fields: [cycleId], references: [id], onDelete: Cascade)
  feeType    String   @map("fee_type") // transport | other
  amountIsk  Decimal  @map("amount_isk") @db.Decimal(28, 2)
  occurredAt DateTime @default(now()) @map("occurred_at")
  memo       String?  @map("memo")
  createdAt  DateTime @default(now()) @map("created_at")

  @@index([cycleId])
  @@index([occurredAt])
  @@map("cycle_fee_events")
}

/// Periodic snapshots for tracking cash, inventory, and profit over time
model CycleSnapshot {
  id             String   @id @default(uuid()) @map("id")
  cycleId        String   @map("cycle_id")
  cycle          Cycle    @relation(fields: [cycleId], references: [id], onDelete: Cascade)
  snapshotAt     DateTime @map("snapshot_at")
  walletCashIsk  Decimal  @map("wallet_cash_isk") @db.Decimal(28, 2)
  inventoryIsk   Decimal  @map("inventory_isk") @db.Decimal(28, 2)
  cycleProfitIsk Decimal  @map("cycle_profit_isk") @db.Decimal(28, 2)
  createdAt      DateTime @default(now()) @map("created_at")

  @@index([cycleId])
  @@index([snapshotAt])
  @@map("cycle_snapshots")
}

/// Historical record of committed courier packages
model CommittedPackage {
  id                     String    @id @default(uuid()) @map("id")
  cycleId                String    @map("cycle_id")
  cycle                  Cycle     @relation(fields: [cycleId], references: [id], onDelete: Cascade)
  packageIndex           Int       @map("package_index")
  destinationStationId   Int       @map("destination_station_id")
  destinationName        String?   @map("destination_name")
  collateralIsk          Decimal   @map("collateral_isk") @db.Decimal(28, 2)
  shippingCostIsk        Decimal   @map("shipping_cost_isk") @db.Decimal(28, 2)
  estimatedProfitIsk     Decimal   @map("estimated_profit_isk") @db.Decimal(28, 2)
  status                 String    @default("active") @map("status") // active | failed | completed
  committedAt            DateTime  @default(now()) @map("committed_at")
  failedAt               DateTime? @map("failed_at")
  collateralRecoveredIsk Decimal?  @map("collateral_recovered_isk") @db.Decimal(28, 2)
  failureMemo            String?   @map("failure_memo")
  createdAt              DateTime  @default(now()) @map("created_at")
  updatedAt              DateTime  @updatedAt @map("updated_at")

  items          CommittedPackageItem[]
  cycleLineLinks PackageCycleLine[]

  @@index([cycleId])
  @@index([status])
  @@map("committed_packages")
}

/// Items in a committed package at time of commit
model CommittedPackageItem {
  id         String           @id @default(uuid()) @map("id")
  packageId  String           @map("package_id")
  package    CommittedPackage @relation(fields: [packageId], references: [id], onDelete: Cascade)
  typeId     Int              @map("type_id")
  typeName   String           @map("type_name")
  units      Int              @map("units")
  unitCost   Decimal          @map("unit_cost") @db.Decimal(28, 2)
  unitProfit Decimal          @map("unit_profit") @db.Decimal(28, 2)
  createdAt  DateTime         @default(now()) @map("created_at")

  @@index([packageId])
  @@index([packageId, typeId])
  @@map("committed_package_items")
}

/// Junction table linking packages to cycle lines (many-to-many)
model PackageCycleLine {
  id             String           @id @default(uuid()) @map("id")
  packageId      String           @map("package_id")
  package        CommittedPackage @relation(fields: [packageId], references: [id], onDelete: Cascade)
  cycleLineId    String           @map("cycle_line_id")
  cycleLine      CycleLine        @relation(fields: [cycleLineId], references: [id], onDelete: Cascade)
  unitsCommitted Int              @map("units_committed")
  createdAt      DateTime         @default(now()) @map("created_at")

  @@unique([packageId, cycleLineId])
  @@index([packageId])
  @@index([cycleLineId])
  @@map("package_cycle_lines")
}

/// Normalized catalog of skill types derived from the EVE SDE
model SkillDefinition {
  /// EVE type ID for this skill
  typeId             Int      @id @map("type_id")
  type               TypeId   @relation(fields: [typeId], references: [id], onDelete: Cascade)
  /// Group ID for this skill (e.g. Gunnery, Spaceship Command)
  groupId            Int      @map("group_id")
  /// English display name for the skill (denormalized from SDE types.jsonl)
  nameEn             String?  @map("name_en")
  /// English description text for the skill (denormalized from SDE types.jsonl)
  descriptionEn      String?  @map("description_en")
  /// Skill rank (1,2,3,...) derived from dogma skillTimeConstant
  rank               Int?     @map("rank")
  /// Primary attribute name for this skill (intelligence, perception, etc.)
  primaryAttribute   String?  @map("primary_attribute")
  /// Secondary attribute name for this skill
  secondaryAttribute String?  @map("secondary_attribute")
  /// First prerequisite skill ID (from dogma attribute 182)
  prerequisite1Id    Int?     @map("prerequisite1_id")
  /// Required level for first prerequisite (from dogma attribute 277)
  prerequisite1Level Int?     @map("prerequisite1_level")
  /// Second prerequisite skill ID (from dogma attribute 183)
  prerequisite2Id    Int?     @map("prerequisite2_id")
  /// Required level for second prerequisite (from dogma attribute 278)
  prerequisite2Level Int?     @map("prerequisite2_level")
  /// Third prerequisite skill ID (from dogma attribute 184)
  prerequisite3Id    Int?     @map("prerequisite3_id")
  /// Required level for third prerequisite (from dogma attribute 279)
  prerequisite3Level Int?     @map("prerequisite3_level")
  createdAt          DateTime @default(now()) @map("created_at")
  updatedAt          DateTime @updatedAt @map("updated_at")

  @@index([groupId])
  @@map("skill_definitions")
}

/// Reusable parameter profiles for tradecraft admin tools
model ParameterProfile {
  id          String                @id @default(uuid()) @map("id")
  name        String                @map("name")
  description String?               @map("description")
  scope       ParameterProfileScope @map("scope")
  params      Json                  @map("params")
  createdAt   DateTime              @default(now()) @map("created_at")
  updatedAt   DateTime              @updatedAt @map("updated_at")
  createdBy   String?               @map("created_by") // User ID of creator

  @@unique([scope, name])
  @@index([scope])
  @@map("parameter_profiles")
}

// ============================================================================
// Tradecraft Strategy Lab (paper trading / backtesting)
// ============================================================================

model TradeStrategy {
  id          String   @id @default(uuid()) @map("id")
  name        String   @map("name")
  description String?  @map("description")
  params      Json     @map("params") // compatible with PlanPackagesRequest shape
  isActive    Boolean  @default(true) @map("is_active")
  createdBy   String?  @map("created_by")
  createdAt   DateTime @default(now()) @map("created_at")
  updatedAt   DateTime @updatedAt @map("updated_at")

  runs TradeStrategyRun[]

  @@unique([name])
  @@index([isActive])
  @@map("trade_strategies")
}

model TradeStrategyRun {
  id                String                 @id @default(uuid()) @map("id")
  strategyId        String                 @map("strategy_id")
  strategy          TradeStrategy          @relation(fields: [strategyId], references: [id], onDelete: Cascade)
  status            TradeStrategyRunStatus @default(QUEUED) @map("status")

  startDate DateTime @map("start_date") @db.Date
  endDate   DateTime @map("end_date") @db.Date

  // Core assumptions
  initialCapitalIsk Decimal                 @map("initial_capital_isk") @db.Decimal(28, 2)
  sellModel         TradeStrategySellModel  @map("sell_model")
  sellSharePct      Decimal?                @map("sell_share_pct") @db.Decimal(10, 6)
  priceModel        TradeStrategyPriceModel @default(LOW) @map("price_model")

  assumptions Json? @map("assumptions") // fee settings, source station, etc.
  summary     Json? @map("summary") // cached metrics for lists
  error       String? @map("error")

  startedAt  DateTime? @map("started_at")
  finishedAt DateTime? @map("finished_at")

  createdAt DateTime @default(now()) @map("created_at")
  updatedAt DateTime @updatedAt @map("updated_at")

  days      TradeStrategyRunDay[]
  positions TradeStrategyRunPosition[]

  @@index([strategyId])
  @@index([status])
  @@index([startDate, endDate])
  @@map("trade_strategy_runs")
}

model TradeStrategyRunDay {
  id    String          @id @default(uuid()) @map("id")
  runId String          @map("run_id")
  run   TradeStrategyRun @relation(fields: [runId], references: [id], onDelete: Cascade)

  date DateTime @map("date") @db.Date

  cashIsk           Decimal @map("cash_isk") @db.Decimal(28, 2)
  inventoryCostIsk  Decimal @map("inventory_cost_isk") @db.Decimal(28, 2)
  inventoryMarkIsk  Decimal @map("inventory_mark_isk") @db.Decimal(28, 2)
  realizedProfitIsk Decimal @map("realized_profit_isk") @db.Decimal(28, 2)
  unrealizedProfitIsk Decimal @map("unrealized_profit_isk") @db.Decimal(28, 2)
  navIsk            Decimal @map("nav_isk") @db.Decimal(28, 2)

  createdAt DateTime @default(now()) @map("created_at")

  @@unique([runId, date])
  @@index([runId])
  @@index([date])
  @@map("trade_strategy_run_days")
}

model TradeStrategyRunPosition {
  id    String          @id @default(uuid()) @map("id")
  runId String          @map("run_id")
  run   TradeStrategyRun @relation(fields: [runId], references: [id], onDelete: Cascade)

  destinationStationId Int @map("destination_station_id")
  typeId               Int @map("type_id")
  type                 TypeId @relation(fields: [typeId], references: [id], onDelete: Restrict, onUpdate: Cascade)

  plannedUnits Int @map("planned_units")

  buyUnitPriceIsk Decimal @map("buy_unit_price_isk") @db.Decimal(28, 2)
  unitsSold       Int     @default(0) @map("units_sold")
  unitsRemaining  Int     @default(0) @map("units_remaining")

  costBasisIskRemaining Decimal @map("cost_basis_isk_remaining") @db.Decimal(28, 2)
  realizedProfitIsk     Decimal @map("realized_profit_isk") @db.Decimal(28, 2)

  createdAt DateTime @default(now()) @map("created_at")
  updatedAt DateTime @updatedAt @map("updated_at")

  @@unique([runId, destinationStationId, typeId])
  @@index([runId])
  @@index([destinationStationId])
  @@index([typeId])
  @@map("trade_strategy_run_positions")
}
